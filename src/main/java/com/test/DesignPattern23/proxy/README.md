### 🍀 代理模式

 - ☘ 1 代理模式
 
    - 三个必要条件: 
    
        - 两个角色: 执行者, 被代理对象
        - 注重过程 
        - 执行者必须拿到被代理对象的引用
        
    - 代理模式底层做的一件事, 就是*字节码重组*
    - 作用:
        - 可以在方法调用前做些事情, 在方法调用后做些事情, 
        - 比如: AOP: 事务代理(声明式事务,可以自定义那些方法需要加事务), 日志监听
            ```
            如:事务:
            1.开启一个事务(open)
            
            *2.事务方法的执行(我们自己的方法)*
            
            3.监听是否有异常,根据异常类型判断是否需要回滚(commit/rollback)
            
            4.事务关闭(close)
            
            ```
            我们只需关系第二步自己的事情,,其他的都是AOP动态的帮我们加上执行的...

  *从代理模式到静态代理*

 - ☘ 2 静态代理
     * 静态代理群在的问题: *
        - 违反了开闭原则, 扩展性差,可维护性差
         每次有新的需求就要修改代理类, 不能只专注业务逻辑, 不符合开闭原则: 对扩展是开放的, 对修改是关闭的
         
        
*从静态代理到动态代理*

 - ☘ 3 动态代理
    - 3.1 jdk动态代理 必须要实现一个接口
           
         原理:
             拿到被代理人对象引用,然后获取他的接口
             jdk代理重新生成一个类, 同时实现我们给的代理人对象所实现的接口
             重新生成一个class字节码
             然后编译
             创建一个代理人....
                 
    - 3.2 cglib动态代理
    
    - jdk动态代理与cglib动态代理的区别
    
      - JDk的动态代理是通过接口来进行强制转换的, 生成后的代理对象,可以强制转换为接口
      - cglib的动态代理是通过生成一个被代理对象的子类,然后重写父类方法, 生成后的对象,可以强制转换为被代理对象,也就是用自己写的类,子类引用赋值给父类
      - jdk动态代理需要持有被代理人的引用作为成员变量, 因为 method.invoke(this.target,args);方法执行,需要对象.方法名进行调用.
        而cglib好像不持有被代理人的引用,(其实cglib帮我们new出来的)
### 知识点
 - 类完整的生命周期
 
    ![图片](https://github.com/tantaizhijun/javaLearning/blob/master/src/main/java/com/test/DesignPattern23/proxy/imgQuote/001.jpg)
   